<?php
/**
 * ImportApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Maileva / Création et envoi de Lettres Recommandées Electroniques qualifiées
 *
 * API pour créer et envoyer des Lettres Recommandées Electroniques qualifiée  Elles comprennent les fonctions clés pour :   - créer un envoi,  - ajouter des documents et des destinataires,  - choisir ses options (Nom, Champ libre, référence dossier, référence client)  - envoyer ses lettres recommandées électroniques qualifiées.    **Paramétrage de compte expéditeur :**     Chaque expéditeur d'une Lettre Recommandée Electronique qualifiée doit posséder un compte expéditeur. Il est donc nécessaire de paramétrer son compte expéditeur en passant par l'API <a href=\"/developpeur/electronic_mail_emitter\"> electronic_mail_emitter</a> ou en se connectant à son espace client www.maileva.com et en suivant les étapes de paramétrage de compte sur le produit Lettre Recommandée Electronique qualifiée.     Une fois le paramétrage du compte finalisé, vous recevrez sous 72h, un recommandé papier à l'adresse postale de l'expéditeur. Il contient un QR Code, la clé OTP et les explications nécessaires pour l'utiliser et générer ses codes à usage unique. Ces informations sont personnelles et confidentielles.    **Authentification OTP :**    L'authentification OTP est obligatoire pour effectuer des envois de Lettres Recommandées Electroniques qualifiées. La clé OTP doit être demandée à l'expéditeur à chaque envoi. Elle permet de générer un code à usage unique permettant une authentification à un niveau renforcé. Cette clé OTP ne doit pas être stockée dans votre application.     Pour générer un code à usage unique vous pouvez :     - Demander à l'expéditeur de télécharger une application mobile telle Google Authenticator ou Free OTP puis de scanner le QR Code sur son smartphone.     - Demander à l'expéditeur d'utiliser un générateur de codes à usage unique depuis son navigateur (par exemple : https://otp-client.ar24.fr/) et de recopier sa clé OTP de 32 caractères présente sur les identifiants papiers obtenus.
 *
 * The version of the OpenAPI document: 1.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException;
use Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Configuration;
use Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\HeaderSelector;
use Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ObjectSerializer;

/**
 * ImportApi Class Doc Comment
 *
 * @category Class
 * @package  Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ImportApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addressesImportsAddressesImportIdDelete' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdGet' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdRecipientsDelete' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdRecipientsGet' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdRecipientsRecipientIdDelete' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdRecipientsRecipientIdGet' => [
            'application/json',
        ],
        'addressesImportsAddressesImportIdRecipientsRecipientIdPatch' => [
            'application/json',
        ],
        'addressesImportsGet' => [
            'application/json',
        ],
        'addressesImportsPost' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addressesImportsAddressesImportIdDelete
     *
     * Supprime l&#39;import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addressesImportsAddressesImportIdDelete($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdDelete'][0])
    {
        $this->addressesImportsAddressesImportIdDeleteWithHttpInfo($addresses_import_id, $contentType);
    }

    /**
     * Operation addressesImportsAddressesImportIdDeleteWithHttpInfo
     *
     * Supprime l&#39;import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdDeleteWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdDelete'][0])
    {
        $request = $this->addressesImportsAddressesImportIdDeleteRequest($addresses_import_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdDeleteAsync
     *
     * Supprime l&#39;import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdDeleteAsync($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdDelete'][0])
    {
        return $this->addressesImportsAddressesImportIdDeleteAsyncWithHttpInfo($addresses_import_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdDeleteAsyncWithHttpInfo
     *
     * Supprime l&#39;import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdDeleteAsyncWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdDelete'][0])
    {
        $returnType = '';
        $request = $this->addressesImportsAddressesImportIdDeleteRequest($addresses_import_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdDelete'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdDeleteRequest($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdDelete'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdDelete'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdDelete, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdGet
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsAddressesImportIdGet($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdGet'][0])
    {
        list($response) = $this->addressesImportsAddressesImportIdGetWithHttpInfo($addresses_import_id, $contentType);
        return $response;
    }

    /**
     * Operation addressesImportsAddressesImportIdGetWithHttpInfo
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdGetWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdGet'][0])
    {
        $request = $this->addressesImportsAddressesImportIdGetRequest($addresses_import_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdGetAsync
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdGetAsync($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdGet'][0])
    {
        return $this->addressesImportsAddressesImportIdGetAsyncWithHttpInfo($addresses_import_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdGetAsyncWithHttpInfo
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdGetAsyncWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdGet'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport';
        $request = $this->addressesImportsAddressesImportIdGetRequest($addresses_import_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdGet'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdGetRequest($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdGet'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdGet'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdGet, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsDelete
     *
     * Supprime tous les destinataires
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addressesImportsAddressesImportIdRecipientsDelete($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'][0])
    {
        $this->addressesImportsAddressesImportIdRecipientsDeleteWithHttpInfo($addresses_import_id, $contentType);
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsDeleteWithHttpInfo
     *
     * Supprime tous les destinataires
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdRecipientsDeleteWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'][0])
    {
        $request = $this->addressesImportsAddressesImportIdRecipientsDeleteRequest($addresses_import_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsDeleteAsync
     *
     * Supprime tous les destinataires
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsDeleteAsync($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'][0])
    {
        return $this->addressesImportsAddressesImportIdRecipientsDeleteAsyncWithHttpInfo($addresses_import_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsDeleteAsyncWithHttpInfo
     *
     * Supprime tous les destinataires
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsDeleteAsyncWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'][0])
    {
        $returnType = '';
        $request = $this->addressesImportsAddressesImportIdRecipientsDeleteRequest($addresses_import_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdRecipientsDelete'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdRecipientsDeleteRequest($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsDelete'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdRecipientsDelete'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsDelete, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsGet
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsAddressesImportIdRecipientsGet($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'][0])
    {
        list($response) = $this->addressesImportsAddressesImportIdRecipientsGetWithHttpInfo($addresses_import_id, $contentType);
        return $response;
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsGetWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdRecipientsGetWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'][0])
    {
        $request = $this->addressesImportsAddressesImportIdRecipientsGetRequest($addresses_import_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsGetAsync
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsGetAsync($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'][0])
    {
        return $this->addressesImportsAddressesImportIdRecipientsGetAsyncWithHttpInfo($addresses_import_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsGetAsyncWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsGetAsyncWithHttpInfo($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipients';
        $request = $this->addressesImportsAddressesImportIdRecipientsGetRequest($addresses_import_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdRecipientsGet'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdRecipientsGetRequest($addresses_import_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsGet'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdRecipientsGet'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsGet, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdDelete
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdDelete($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'][0])
    {
        $this->addressesImportsAddressesImportIdRecipientsRecipientIdDeleteWithHttpInfo($addresses_import_id, $recipient_id, $contentType);
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdDeleteWithHttpInfo
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdDeleteWithHttpInfo($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'][0])
    {
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdDeleteRequest($addresses_import_id, $recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdDeleteAsync
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdDeleteAsync($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'][0])
    {
        return $this->addressesImportsAddressesImportIdRecipientsRecipientIdDeleteAsyncWithHttpInfo($addresses_import_id, $recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdDeleteAsyncWithHttpInfo
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdDeleteAsyncWithHttpInfo($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'][0])
    {
        $returnType = '';
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdDeleteRequest($addresses_import_id, $recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdRecipientsRecipientIdDelete'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdDeleteRequest($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdDelete'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdDelete'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdDelete, must be smaller than or equal to 40.');
        }
        
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdDelete'
            );
        }
        if (strlen($recipient_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$recipient_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdDelete, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }
        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdGet
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdGet($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'][0])
    {
        list($response) = $this->addressesImportsAddressesImportIdRecipientsRecipientIdGetWithHttpInfo($addresses_import_id, $recipient_id, $contentType);
        return $response;
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdGetWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdGetWithHttpInfo($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'][0])
    {
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdGetRequest($addresses_import_id, $recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdGetAsync
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdGetAsync($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'][0])
    {
        return $this->addressesImportsAddressesImportIdRecipientsRecipientIdGetAsyncWithHttpInfo($addresses_import_id, $recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdGetAsyncWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdGetAsyncWithHttpInfo($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipient';
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdGetRequest($addresses_import_id, $recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdRecipientsRecipientIdGet'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdGetRequest($addresses_import_id, $recipient_id, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdGet'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdGet'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdGet, must be smaller than or equal to 40.');
        }
        
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdGet'
            );
        }
        if (strlen($recipient_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$recipient_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdGet, must be smaller than or equal to 40.');
        }
        

        $resourcePath = '/addresses_imports/{addresses_import_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }
        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdPatch
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipientUpdate $addresses_imports_recipient_update addresses_imports_recipient_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdPatch($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'][0])
    {
        list($response) = $this->addressesImportsAddressesImportIdRecipientsRecipientIdPatchWithHttpInfo($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, $contentType);
        return $response;
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdPatchWithHttpInfo
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipientUpdate $addresses_imports_recipient_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdPatchWithHttpInfo($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'][0])
    {
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdPatchRequest($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdPatchAsync
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipientUpdate $addresses_imports_recipient_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdPatchAsync($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'][0])
    {
        return $this->addressesImportsAddressesImportIdRecipientsRecipientIdPatchAsyncWithHttpInfo($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsAddressesImportIdRecipientsRecipientIdPatchAsyncWithHttpInfo
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipientUpdate $addresses_imports_recipient_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdPatchAsyncWithHttpInfo($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\RecipientResponse';
        $request = $this->addressesImportsAddressesImportIdRecipientsRecipientIdPatchRequest($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsAddressesImportIdRecipientsRecipientIdPatch'
     *
     * @param  string $addresses_import_id Identifiant de l&#39;import (required)
     * @param  string $recipient_id Identifiant du destinataire (required)
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportsRecipientUpdate $addresses_imports_recipient_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsAddressesImportIdRecipientsRecipientIdPatchRequest($addresses_import_id, $recipient_id, $addresses_imports_recipient_update, string $contentType = self::contentTypes['addressesImportsAddressesImportIdRecipientsRecipientIdPatch'][0])
    {

        // verify the required parameter 'addresses_import_id' is set
        if ($addresses_import_id === null || (is_array($addresses_import_id) && count($addresses_import_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_import_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdPatch'
            );
        }
        if (strlen($addresses_import_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$addresses_import_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdPatch, must be smaller than or equal to 40.');
        }
        
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling addressesImportsAddressesImportIdRecipientsRecipientIdPatch'
            );
        }
        if (strlen($recipient_id) > 40) {
            throw new \InvalidArgumentException('invalid length for "$recipient_id" when calling ImportApi.addressesImportsAddressesImportIdRecipientsRecipientIdPatch, must be smaller than or equal to 40.');
        }
        
        // verify the required parameter 'addresses_imports_recipient_update' is set
        if ($addresses_imports_recipient_update === null || (is_array($addresses_imports_recipient_update) && count($addresses_imports_recipient_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addresses_imports_recipient_update when calling addressesImportsAddressesImportIdRecipientsRecipientIdPatch'
            );
        }


        $resourcePath = '/addresses_imports/{addresses_import_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($addresses_import_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addresses_import_id' . '}',
                ObjectSerializer::toPathValue($addresses_import_id),
                $resourcePath
            );
        }
        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($addresses_imports_recipient_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($addresses_imports_recipient_update));
            } else {
                $httpBody = $addresses_imports_recipient_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsGet
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsGet(string $contentType = self::contentTypes['addressesImportsGet'][0])
    {
        list($response) = $this->addressesImportsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation addressesImportsGetWithHttpInfo
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsGet'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsGetWithHttpInfo(string $contentType = self::contentTypes['addressesImportsGet'][0])
    {
        $request = $this->addressesImportsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsGetAsync
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsGetAsync(string $contentType = self::contentTypes['addressesImportsGet'][0])
    {
        return $this->addressesImportsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsGetAsyncWithHttpInfo
     *
     * Récupérer l&#39;état d&#39;un import étape par étape
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['addressesImportsGet'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImports';
        $request = $this->addressesImportsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsGetRequest(string $contentType = self::contentTypes['addressesImportsGet'][0])
    {


        $resourcePath = '/addresses_imports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addressesImportsPost
     *
     * Démarrer un import étape par étape
     *
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportInput $addresses_import_input addresses_import_input (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsPost'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto
     */
    public function addressesImportsPost($addresses_import_input = null, string $contentType = self::contentTypes['addressesImportsPost'][0])
    {
        list($response) = $this->addressesImportsPostWithHttpInfo($addresses_import_input, $contentType);
        return $response;
    }

    /**
     * Operation addressesImportsPostWithHttpInfo
     *
     * Démarrer un import étape par étape
     *
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportInput $addresses_import_input (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsPost'] to see the possible values for this operation
     *
     * @throws \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto|\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function addressesImportsPostWithHttpInfo($addresses_import_input = null, string $contentType = self::contentTypes['addressesImportsPost'][0])
    {
        $request = $this->addressesImportsPostRequest($addresses_import_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addressesImportsPostAsync
     *
     * Démarrer un import étape par étape
     *
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportInput $addresses_import_input (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsPostAsync($addresses_import_input = null, string $contentType = self::contentTypes['addressesImportsPost'][0])
    {
        return $this->addressesImportsPostAsyncWithHttpInfo($addresses_import_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addressesImportsPostAsyncWithHttpInfo
     *
     * Démarrer un import étape par étape
     *
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportInput $addresses_import_input (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addressesImportsPostAsyncWithHttpInfo($addresses_import_input = null, string $contentType = self::contentTypes['addressesImportsPost'][0])
    {
        $returnType = '\Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImport';
        $request = $this->addressesImportsPostRequest($addresses_import_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addressesImportsPost'
     *
     * @param  \Cube43\Component\MailEva\EnvoiEtSuiviDeLreQualifiees\Model\AddressesImportInput $addresses_import_input (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addressesImportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addressesImportsPostRequest($addresses_import_input = null, string $contentType = self::contentTypes['addressesImportsPost'][0])
    {



        $resourcePath = '/addresses_imports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($addresses_import_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($addresses_import_input));
            } else {
                $httpBody = $addresses_import_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
